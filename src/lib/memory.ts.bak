// src/lib/memory.ts
import fs from "fs/promises";
import path from "path";
import { randomUUID } from "crypto";


export type MemoryItem = {
  id: string;
  title: string;      // local-only label
  content: string;
  tags?: string[];
  createdAt: string;  // ISO
};


const PROVIDER = process.env.MEMORY_PROVIDER ?? "file";


/* ========== FILE (local) ========== */
const DATA_DIR = path.join(process.cwd(), "data");
const DATA_FILE = path.join(DATA_DIR, "memory.json");


async function ensureFileStore() {
  await fs.mkdir(DATA_DIR, { recursive: true });
  try { await fs.access(DATA_FILE); } catch { await fs.writeFile(DATA_FILE, "[]", "utf8"); }
}
async function fileReadAll(): Promise<MemoryItem[]> {
  await ensureFileStore();
  return JSON.parse(await fs.readFile(DATA_FILE, "utf8")) as MemoryItem[];
}
async function fileWriteAll(items: MemoryItem[]) {
  await ensureFileStore();
  await fs.writeFile(DATA_FILE, JSON.stringify(items, null, 2), "utf8");
}
async function fileSaveMemory(input: { title: string; content: string; tags?: string[] }): Promise<MemoryItem> {
  const all = await fileReadAll();
  const item: MemoryItem = { id: randomUUID(), title: input.title, content: input.content, tags: input.tags ?? [], createdAt: new Date().toISOString() };
  all.unshift(item); await fileWriteAll(all); return item;
}
async function fileSearchMemories(q: string): Promise<MemoryItem[]> {
  const all = await fileReadAll();
  return all.filter(m => m.content.includes(q) || m.title.includes(q));
}


/* ========== MEMARA (HTTP) ========== */
const BASE   = (process.env.MEMARA_BASE || "").replace(/\/+$/,""); // no trailing slash
const SAVE   = (process.env.MEMARA_SAVE_PATH   || "/memories");
const SEARCH = (process.env.MEMARA_SEARCH_PATH || "/memories/search");
const INFO   = (process.env.MEMARA_INFO_PATH   || "/info");


const DEFAULT_CATEGORY   = process.env.MEMARA_DEFAULT_CATEGORY || "chat";
const DEFAULT_IMPORTANCE = Number(process.env.MEMARA_DEFAULT_IMPORTANCE || 5);
const SEARCH_LIMIT       = Number(process.env.MEMARA_SEARCH_LIMIT || 10);


function url(pathname: string) {
  if (pathname.startsWith("http")) return pathname;
  if (!BASE) throw new Error("MEMARA_BASE is required");
  return `${BASE}${pathname}`;
}


async function memaraFetch(pathname: string, init: RequestInit = {}) {
  const key = process.env.MEMARA_API_KEY;
  if (!key) throw new Error("MEMARA_API_KEY missing");


  const u = url(pathname);
  const method = (init.method || "GET").toUpperCase();
  console.log("[MEMARA]", method, u);


  const res = await fetch(u, {
    ...init,
    headers: {
      "Content-Type": "application/json",
      "Accept": "application/json",
      Authorization: `Bearer ${key}`,
      ...(init.headers || {}),
    },
    // @ts-expect-error next runtime
    cache: "no-store",
  });


  const ct = res.headers.get("content-type") || "";
  const text = await res.text();
  if (!res.ok) {
    console.error("[MEMARA] ERROR", res.status, method, u, text.slice(0, 200));
    throw new Error(`Memara ${u} ${res.status}: ${text}`);
  }
  if (!ct.includes("application/json")) {
    throw new Error(`Memara returned non-JSON (${ct}): ${text.slice(0, 200)}`);
  }
  return JSON.parse(text);
}


async function memaraSaveMemory(input: { title: string; content: string; tags?: string[] }): Promise<MemoryItem> {
  const body = {
    content: input.content,
    tags: input.tags ?? [],
    category: DEFAULT_CATEGORY,
    importance: DEFAULT_IMPORTANCE
  };
  const data = await memaraFetch(SAVE, { method: "POST", body: JSON.stringify(body) });


  const src: any = data.memory ?? data;
  return {
    id: src.id ?? randomUUID(),
    title: input.title || src.title || "Memory",
    content: src.content ?? input.content,
    tags: src.tags ?? input.tags ?? [],
    createdAt: src.createdAt ?? new Date().toISOString(),
  };
}


async function memaraSearchMemories(q: string): Promise<MemoryItem[]> {
  // Memara requires POST with body {query, limit}
  const body = { query: q, limit: SEARCH_LIMIT };
  const data = await memaraFetch(SEARCH, { method: "POST", body: JSON.stringify(body) });


  const rows: any[] = Array.isArray(data) ? data : data.items ?? data.results ?? [];
  return rows.map((r: any) => ({
    id: r.id ?? randomUUID(),
    title: r.title ?? "(untitled)",
    content: r.content ?? "",
    tags: r.tags ?? [],
    createdAt: r.createdAt ?? new Date().toISOString(),
  }));
}


/* ========== PUBLIC API ========== */
export async function saveMemory(input: { title: string; content: string; tags?: string[] }) {
  if (PROVIDER === "memara") return memaraSaveMemory(input);
  return fileSaveMemory(input);
}
export async function searchMemories(q: string) {
  if (PROVIDER === "memara") return memaraSearchMemories(q);
  return fileSearchMemories(q);
}
export async function memaraInfo() { return memaraFetch(INFO); }

